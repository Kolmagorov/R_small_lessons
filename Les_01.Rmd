---
title: "Lesson_01"
output:
  html_document:
    toc: true
    toc_float: true
---

### НАВИГАЦИЯ

Узнать текущую директорию:

```{r, echo=TRUE}
getwd()
```

Установить новую директорию в качестве рабочей:

```{r}
setwd("C:/")
```

Получить список файлов из текущей папки:

```{r, echo=TRUE}
dir()
```

или в заданой директории , например `C:\RWD`:

```{r}
dir(path="C:/RWD") # Замена обратной косой черты C:\RWD}
```

обратите внимание, что при передачи пути `path` в вункцию `dir` бэкслеш (обратная косая черта `\`), принятый в Windows для записи пути, нужно заменить на косую черту `/` как в UNIX-ситемах) это применимо ко всем функциям в `R`. В противном случае будет синтаксическая ошибка, команда не выполнится:

```{r, error = TRUE}
dir(path="C:\RWD") # С бэкслеш

```

### ТИПЫ ДАННЫХ

В `R` работает динамическая типизация и существуют следующие типы переменных:

-   **numeric** - числовые данные с дробной (десятичной) частью;
-   **integer** - целые числа;
-   **logical** - логический тип (`FALSE` и `TRUE`);
-   **character** *aka string -* символьный/ строчный тип;
-   **complex** - комплексные числа;
-   **posix** - дата и время (точнее это объекты классов POSIX\* ).

Пример разных данных

```{r}
# numeric
a <- 1.5
# integer
int <- 156L
# character aka string
b <- "Science is awesome"
# logical
bool <- a == b
# complex
c <- 15+1i
# создание объекта класса POSIXlt
my_date <- as.POSIXlt(x = "02-02-1988 09:00:00"
                      , format = "%d-%m-%Y %H:%M:%OS"
                      , tz = "Europe/Moscow")

```

Соберем все переменные в одину - структурного типа list:

```{r}
all_stuff <- list(a=a, b=b, c=c, boo=bool, int=int, my_date = my_date )
```

Выведем на печать все сразу, используя переменную `all_stuff`, цикл `for` и в качестве вывода функцию `cat` (но это не обязательно можно и с помощью `print`):

```{r, echo=TRUE}
for (i in names(all_stuff)){
  cat(i
      ," is of type "
      , class(all_stuff[[i]])
      , "\nValue = "
      , as.character(all_stuff[[i]])
      , "\n")
}
```

Узнать тип какой-либо переменной можно с помощью функции `class()`:

```{r, echo=TRUE}
class(a)
```

а также проверить тип переменной или объекта с помощью семейства функций is.{имя типа}:

```{r, echo=TRUE}
is.integer(a)
is.character(b)
is.complex(c)
```

### ОПЕРАТОРЫ

Базовые опреаторы:

```{r}
# Присвоение <- или ->
a<-42

# Сложение +
a + a

# Вычитание -
29 - a

# Умножение * и деление /
0.5*a/88

# Возведение в степень **
a**2

# Возведение в степень ^
a^2
```

`R` поддерживает **векторизацию** - и это, пожалуй, одно из самых больших преимуществ данного языка.

Так применительно к **итерирумым** объектам применять операции и целые функции можно **без явного использования циклов!**

Рассмотрим некоторые математические опреации:

1.  С векторами:

    ```{r}
    # Создадим вектор с количеством компонентов 5
    vec<- c(1,2,3,4,5)
    # Далее проведем некоторые опрерации
    vec + 100
    vec * 10
    vec**2
    vec * vec
    ```

Можно заметить, что все представленные опреции выполняются поэлементно, в том числе между двумя веторами, для векторного умножения по правилам линейной алгебры используют функцию `%*%` матричное умножение.

2.  С матрицами:

    ```{r}
    # Создадим матрицу 3 на 3
    mat<- matrix(1:9, nrow = 3)
    mat

    ```

    ```{r}
    # Далее проведем некоторые опрерации

    mat + 100
    mat * 10
    mat**2
    # И сложение с вектором
    mat + vec


    ```

Обратите внимание, что матрицу размерности 3 на 3, несмотря на несоответствие размерностей, удалось умножить на вектор размерности 5, хотя и с предупреждением .

А вот, что будет, если перемножиь объекты, имеющие одинаковые размерности:

```{r}
# Создадим вектор размерности 3
vec_short <- c(1, 2, 3)
vec_short

```

```{r}
  vec_short + mat
```

Умножение проходит поэлементно между элементами вектора-столбца матрицы и собственно вектор.

В случае матрицы и вектора размерности 5. Лишние 2 элемента вектора используются для умножения на второй вектор-столбец матрицы, при этом, чтобы третьим элементом служит первый компоент вектора.

**Логические операторы:**

```{r}
b <- 11
# Сравнение
a > b
a < b
b <= 11
a >= 19
b != a
a == 42
```

Составные логические операции:

```{r}
# Опреатор логическое И
a > b & a < 3
# Опреатор логическое ИЛИ
a > b | a < 3
# Отрицание
!(a > b)

```

Логические операции с векторами

```{r}
vec <= 6
```

и матрицами:

```{r}
mat > 6
```

Результат представляет собой логический вектор или матрицу соответсвующей размерности. Такие объекты удобно использовать для фильтрации массивов (векторов, матриц) например, нам нужно получить все значения массива `vec` более 3:

```{r}
# Создаем фильтр и сохраняем его в переменную
filt <- vec > 3
# Проверяем как выглядит содержимое фильтра
filt
# Исходный одномерный массив (вектор)
vec
# Значения после фильтрации массива
vec[filt]
```

Попробуйте отфильтровать матрицу самостоятельно.

"Конвеерный" (pipeOP) оператор. Позволяет последовательно выполнять передачу параметров в функции связывая последовательность вызова функций в цепочки:

```{r}
# Зададим строковую переменную
SEQ <- "AADRTTYYYYEEEDYWE"
# Преобразуем строку в одномерный массив символов
tmp_1 <- strsplit(SEQ, split = "")
# Распаовка списка до одномерного массива
tmp_2 <- unlist(tmp_1)
# Подсчет встречаемости символов в массиве
tmp_3 <- table(tmp_2)
# конвертация в dataframe 
result <- data.frame(tmp_3)
# Замена имен столюцов на более понятные
names(result)<-c("AA", "Qty")
result
```

Описанню выше последовательность вызовов можно записать в виде вложенных функций, это делает код более компактным, требует только одной переменной, но код становиться менее читаемым для человека

```{r}

# result<-data.frame(table(unlist(strsplit("AADRTTYYYYEEEDYWE", split = ""))))
# повысить читаемость можно, записав вложениея в виде каскада
result<-data.frame(
  table(
    unlist(
      strsplit("AADRTTYYYYEEEDYWE", split = "")
      )
    )
  )
names(result)<-c("AA", "Qty")
result
```

применение оператора конвеера `|>`, позволяет записать вложение следующим образом

```{r}
result<- "AADRTTYYYYEEEDYWE" |>
  strsplit(x= _, split="") |> 
  unlist() |>
  table() |>
  data.frame()

names(result)<-c("AA", "Qty")
result 

```

`x = _` - placeholder , указывающий куда именно поместить значение результата из конвеера. Работает толбко с именнованными параметрами.

`|>` - опреатор входит в базовый пакет `R` . Существует также оператор конвеера `%>%` (`SHIFT+CNTRL+M`) из пакета `magrittr` ; выполняет тоже самое, что и базовый `|>` , но имеет чуть больше возможностей по передаче данных (см. справку). Та же цепочка с оператором `%>%` :

```{r}
# Подгружаем библиотеку magrittr, т.к. в ней оператор %>% 
require(magrittr)

result<- "AADRTTYYYYEEEDYWE" %>% 
  strsplit(., split="") %>%  # placeholder !!!
  unlist() %>% 
  table() %>% 
  data.frame()

names(result) <- c("AA", "Qty")
result 
```

Обратите внимание, в качестве `placeholder`, с `%>%` используется `.` и применять его в отличии от `|>` можно позиционно, т.е. без вызова имени параметра.

Существуют и другие конвеерные операторы : `%<>%`, `%T>%`, `%$%`.

Бинарный оператор сопоставления/совпадения `%in%`.

Возвращает логический вектор совпадений:

```{r}
a <- c("A","B", "C", "D","E", "Z","XX", "TRE")
b <- c("B","B", "C", "F","F")
# Операция не симметрична!!
a %in% b
# не то же самое что
b %in% a

```

`%in%`  - очень удобен при фильтрации массивов.

Например, есть вектор уникальных значений `a`, и вектор `b` элементы которого могут повторяться и содержать некоторые или все элементы уникального вектора `a` . Пусть нам необходимо выполнить поиск и вернуть все элементы в вектрое `b` совпадающие с элементами вектора `a`:

```{r}
b[b %in% a]
```

для работы с группами также удобно пользоваться операциями над группами (Set Operations)

### СТРУКТУРНЫЕ ТИПЫ

-   массивы
    -   одномерные (vector)
    -   двумерные (matrix)
    -   многомерные (array)
-   списки (list)
-   data.frame, [tibble](https://tibble.tidyverse.org/articles/tibble.html "tidyverse tibble")
-   factors

Способы задания вектора (одномерного массива):

```{r}
# С помощью записи последовательности
vec_a <- 1:9
# с помощью функции seq
vec_b <- seq(1, 9, 0.5)
# с помощью функции rep
vec_rep <- rep(0, 6)
# В ручную
vec_c <- c("a", "string", 42, TRUE) # integer преобразуется в character
vec_d <- c(42, FALSE, NA)

vec_a
vec_b
vec_c
vec_d
vec_rep
```

Обратите внимание, что массив может содержать только данные одного типа. При передаче в массив гетерогенных данных как в `vec_c` и `vec_d`, просиходит, так называемое, *неявное приведение типов*.

Так `TRUE` и `FALSE` переводятся в 1 и 0 соответсвенно, если совмещены с `numeric` или `integer`, и в строковый тип, если находятся в одном массиве с хотя бы одним элементом `character`. Соответсвенно **все типы** переводятся в `character` при наличие в массиве хотя бы одного элемента типа `character`.

В `vec_d` помещен специальный элемент `NA` - индикатор отсутсвующего элемента, иначе пустота. `NA` приводится к любому типу и всегда остабражается как `NA`. Подробнее `help(NA)`. Для поиска отсутствующих значений в массиве удобно использовать функцию `is.na()`:

```{r}
is.na(vec_d)
```

Мы можем также посчитать количество пустых элементов в массиве:

```{r}
# Используем функцию суммирования элементов
sum(is.na(vec_d))
```

Как можно заметить выше, к логическому вектору применеа функция сложеия, котороя вообще говоря, должна работь с числовыми данными. Тем не менее, за счет *неявного приведения типов* логический вектор был преобразован в вектор целых чисел с элементами из нулей и единиц, которые в итоге функция `sum()` и сложила. Результат по смыслу - количество пустых элементов.

Результат можно обратить, т.е. получить количество НЕпустых элементов, если к логическому вектору применить оператор отрицания `!`:

```{r}
# Исходный логический вектор
is.na(vec_d)
# Обращенный логический вектор
!is.na(vec_d)
# Количество НЕпустых элементов
sum(!is.na(vec_d))
```

Нужно понимать, что `NA` это не ноль `0`. Так некторые функции по умолчанию обрабатывают `NA` выдавая результат `NA`:

```{r}
foo <- c(9, 12, 16, NA)
mean(foo)
```

если нет необходимости в чистке массива можно поступать так:

```{r}
foo <- c(9, 12, 16, NA)
# Установить флаг na.rm - remove NA- в положение ИСТИНА
mean(foo, na.rm = TRUE)
```

как правило данный параметр `na.rm` есть во всех функциях, выполняющих математические опреации с элемиентами массиов.

Двумерный массив (матрица), можно инициализировать из вектора общее количество элемнтов которого будет равно произведению количества строк и столбцов конструируемой матрицы:

```{r}
# Создаём вектор заданной длины
vec <- 1:12

mat <- matrix(data = vec, nrow = 3, byrow = TRUE
              , dimnames = list(c(1,2,3), c("A", "B", "C"," D")))

mat
```

столбцам и строкам матрицы можно присвоить имена, для это в параметр `dimnames` передают список из имен строк и столбцов соответственно (также возможно передать только имена строк)

```{r}

mat_named <- matrix(data = vec, nrow = 3, byrow = TRUE
              , dimnames = list(c("ROW_1", "ROW_2", "ROW_3")
                                , c("A", "B", "C"," D")))
mat
```

`list()` - конструктор списков. Списк - это контейнер, хронящий разные объекты, например числа, строки, массивы чисел и строк, объекты, например data.frame и даже вложенные списки.

```{r}
# Создаем список
small <- list (A = 1:12, B = LETTERS[26:13])

# И еще один, побольше

my_list <- list(item_1 = 1:25
                , item_2 = LETTERS[1:15]
                , item_3 = NULL
                , item_4 = matrix(1:10, nrow = 2)
                , samll_list = small # Вкладываем список внутрь списка
                )
```

С помощь функции `str()` (сокращ. от structure - структура) можно посмотреть структуру списка в консоли:

```{r}
str(small)
str(my_list)
```

Имена объектов, если они быди присвоены можно вывести, используя функцию `names()`:

```{r}
names(my_list)
```

При этом выводятся имена только первого уровня, имена объектов вложенных списков не выводятся.

объекты можно вызывать по индексам (порядковым номерам в списке):

```{r}
# Извлечение одного элемента с индексом 3
my_list[3]
# Нескольких элементов
my_list[2:5]
# Извлечение имени
my_list["item_2"]

# По имени через символ $
my_list$item_3

```

Таким образом, чтобы вызвать вложенный список, обращаемся к элементу `samll_list` в списке `my_list`:

```{r}
names(my_list$samll_list)
```

Добавить новый элемент к списку

```{r}
my_list$New_item <- "Say hello to a new item"
```

`data.frame()` - одноименной конструктор для класса data.frame - это структурный тип данных, визуально напоминающий обычную таблицу, каждая колонка которой может хранить свой тип данных, при этом каждый столбец имеет уникальное название, формируя, таким образом, шапку таблицы. Возможно также дать названия строкам как в в примере с матрицами. Класс data.frame - лучше всего подходит для импорта и экспорта привычных в нашем понимании таблиц.

```{r}
# Создаем data.frame с двумя колонками Group Value и Person
# При этом строкам имена как колонке Person

df <- data.frame(Group = LETTERS[1:5]
                 , Value = (1:5)*0.75
                 , Person = c("Ivan", "Vasyan", "Vovan", "Simon","John")
                 , row.names = c("Ivan", "Vasyan", "Vovan", "Simon","John")
                 )
df

```

Класс объекта data.frame

```{r}
# возвразаемый тип/класс
class(df)
```

колонки data.frame можно вызывать по именам, по аналогии со списками:

```{r}
# Непосредственно по названию
df["Person"]
# По индексу (порядку следования в data.frame)
df[3]
# Через $
df$Value
```

`names()` - выводит названия всех колонок, т.е. шапку "таблицы" data.frame:

```{r}
names(df)
```

К индексам строк также можно обращаться, используя следующий правило: на первом месте указывают номер(а) строки и через `,` номера или имена столбцов; при этом, если ничего не указать посде запятой, то будут выбаны все доступные столбцы

```{r}
# Выбрать первую строку и все столбцы
df[1,]
# со 2 по 4 строки и с 1 по 2 столбцы
df[2:4, 1:2]
# Извлечь все строки кроме первой,  а также с 1 по 3 столбцы в ОБРАТНОМ порядке
df[-1, 3:1]
# Извлечь все строки и только один столбец по имени, результатом данной операции 
# будет одномерный массив
a <- df[,"Value"]
a
class(a)
```

названия всех строк можно вывести командой `rownames`

```{r}
rownames(df)

# с помощью этой же команды можно переименовать все строки
rownames(df) <- LETTERS[11:15]
df

# или "обнулить" имена строк
rownames(df)<- NULL
df
```

**ЗАДАНИЕ** Попробуйте самостоятельно извлечь индивидуальные значения из `data.frame`:

\- используя числовые индексы как в примере с матрицей;

\- используя именованные индексы строк и столбцов;

-   создайте новый столбец (придумайте имя), используя символ `$` как в примере со списками, и заполните его результатом `sin()` значений столбца `Value`.

    Решение:

    ```{r}
    df$Results <- sin(df$Value)
    df
    ```

### ВСТРОЕННЫЕ ФУНКЦИИ

*Конструкторы массивов*

`c()` - создание простого одномерного массива;

`matrix()` - создание двумерного массива;

Существуеи встроенный массив букв латинского алфавита

`letters` - строчные;

`LETTERS` - прописные

Пример:

```{r}
letters
LETTERS
```

данные объекты как и любые одномеррные массивы подвержены операциям выборки:

```{r}
# Первые пять строчных букв
letters[1:5]
# В обратном порядке 5 ЗАГЛАВНЫХ 
LETTERS[26:21]
```

*Конструкторы структурных типов:*

`list()` - конструктор списков:

```{r}
my_list <- list(item_1 = 1:25
                , item_2 = LETTERS[1:15]
                , item_3 = NULL
                , item_4 = matrix(1:10, nrow = 2))
my_list

```

`vector()` - конструктор для создания пустых списков (которые потом, например, можно заполнить результатми расчетов):

```{r}
my_fancy_list <- vector(mode = "list", length = 6)
my_fancy_list
```

`lenght()` - возвращает количество элементов итерируемого объекта:

```{r}
# В data.frame это количество колонок
length(df)
# В списках - количество элементов
length(my_fancy_list)
# В одномерном массиве и матрице, возвращает количество элементов массива
vec <- 1:12
length(vec)

```

Арифметические функции

`sum()` - сумма элементов массива

```{r}

```

`mean()` - среднее арифметическое значений элеметов массива

`median()` - медиана значений элеметов массива

`sd()` - стандартное отклонение значений элеметов массива

Генераторы псевдослучайных случайных чисел (PRNG)

`rnorm()` - генерирует выборку заданого объема из нормального распределения с заданными параметрами `mu` и `sigma` :

```{r}
set.seed(1988)
norm_vec <- rnorm(n = 25, mean = 100, sd = 2)
norm_vec

summary(norm_vec)
```

`runif()` - генерирует выборку заданого объема из равномерного распределения на заданном интервале:

```{r}
set.seed(1988)
uniform_vec <- runif(n = 25, min = 10, max = 20)
uniform_vec

summary(uniform_vec)

```

`summary()` - вохвращает обобщенную инфомацию об содержимом объекта, объем возвращаемой информации зависит от объекта, для массивов это простая статистика (см. пример выше), для списков:

```{r}
summary(my_list)
```

Функции печати

`print()` - вывод **на печать** значений в КОНСОЛЬ;

```{r}
print("HELLO WORLD")
print(1:25)
```

`cat()` - объединнние значений нескольких параметров в единую строку и вывод полученой строки в консоль или внешний файл;

```{r}
age <- 25
my_name <- "John"
cat("My name is ", my_name, " I'am ", age, "years old")
```

Set Operations:

`setdiff()` возвращает элеменыт

`intersect()`  - возвращает общие элеменыты сравниваемых групп

`union()`  - объединяет элементы групп.

```{r}
a <- c("A","B", "C", "D","E", "Z","XX", "TRE")
b <- c("B","B", "C", "F","F")
# Асимметричная разница
setdiff(a,b)
setdiff(b,a)
# Пересечение
intersect(a,b)
# объединение
union(a,b)
```

количество повторяющихся элементов не учитывается.

Поиск дупликатов (повторений)

`duplicated` ():

```{r}
duplicated(b)
# отфильтровать и вернуть повторяющиеся элементы
b[duplicated(b)]

# отфильтровать и вернуть НЕповторяющиеся элементы
b[!duplicated(b)]
```

Поиск уникальных значений в массив, можно выполнить с помощью функции `unique()`

```{r}
unique(b)

# Эквивалентно b[!duplicated(b)]
un_b <- unique(b)
ndp <- b[!duplicated(b)]

# Проверка на предмет различия перечня элементов между двумя способами
setdiff(un_b, ndp) 
setdiff(ndp, un_b)
```

### РАБОТА СО СТРОКАМИ

Количество символов в строке в ом числе пробелов

```{r}
SEQ <- "P E P TIDE"
nchar(SEQ)
```

`paste()` на подобии `cat()` выполняет объединнние значений нескольких параметров в единую строку и вывод полученой строки или в пременную или в консоль :

```{r}
age <- 25
my_name <- "John"

new_string <- paste("My name is ", my_name, " I'am ", age, "years old")
new_string

```

Аргумент `sep` - задает символы - разделити между объединяемыми значениями перемнных:

```{r}
age <- 25
my_name <- "John"

new_string <- paste("My name is ", my_name, " I'am ", age, "years old", sep = "__")
new_string
```

Аргумент `collapse` - задает символы - разделити между объединяемыми значениями элементов массива:

```{r}
# объединим два массива чисел и строчных букв
# Оъединение элементов просиходит попарно

paste(1:5, letters[1:5], sep =  " to ", collapse = "; ")
```

`strsplit()` разбивает строку на отдельные символы и возвращаетв виде одномерного массива внутри списка (пробелы также считаются символом), разбиение на элементы можно регулировать параметром `split`

```{r}
SEQ <- "PEPTIDE"
# Если split пустой
strsplit(x = SEQ, split = "")

some_txt <- " Hey Boys, Hey Girls"
# Если split ','
strsplit(x = some_txt, split = ",")
# Если split 'пробел'
strsplit(x = some_txt, split = " ")
```

В качестве входных данных может быть и массив строк:

```{r}
# Одномерный массив строк
peps <- c("PEPTIDE", "LARGEPEPTIDE", "VERYLARGEPEPTIDE")
# Разбиение каждого элемента (слова) на массив отдельных символов
strsplit(x = peps, split = "")
```

ЗАДАНИЕ 1

создать массив из 5 элементов вида `"Имя_Фамилия_Возраст"`, разбейте каждую строку на три отдельных компонента `Имя`, `Фамилия`, `Возраст` .

Попробуййте найти способ преобразовать полученный списко в data.frame, со столбцами: first_name , last_name, age.

ЗАДАНИЕ 2

Написать функцию, которая на вход принимает строку, возвращает количество каждого символа, содержащегося в последовательности строки.

Входной параметр: строка - последовательность аминокислот.

Возвращаемое значение - датафрейм. Столбцы: символ аминокислоты, количество АА в последовательности, доля АА (%) от от всех кислот.

Значения в последнем столбце (доля АА (%) ) округлить до второго знака после запятой.

Названия столбцов должно отражать содержимое. (Имена на английской раскладке без пробелов)

ЗАДАНИЕ 3

Расширить возможности функции prettySEQ (практические занятия), функцией задания 2. Возвращаемое значение представить в виде именованого списка (`list`), содержащего отфарматированную матрицу сиквенса, и датафрейм с составом АА кислот.

TO BE CONTINUED...
