---
title: "Lesson_03"
output:
  html_document:
    toc: true
    toc_float: true
---

## ГРАФИКИ И ДИАГРАММЫ

Для построения графиков и диаграмм наиболее часто используют следующие библиотеки

-   `plot {base}` - базовая графика;

-   `ggplot2 {ggplot2 }` - продвинутая графика на основе "грамматических структур";

-   `{lattice}` - Trellis graphics for **R** .

### PLOT

Данные можно строить на рзных типах. Данный пример демонстирует построение простого графика с ипользованием `data.frame` в качестве данных и функцию `plot` .

```{r}
df <- data.frame(X=1:25, Y=5*(1:25)+9)
plot(x = df$X, y = df$Y, col ="red")
```

Предустановлены следующие типы точек (маркеров) :

```{r}
plot(x = df$X, y = df$Y, col ="blue", pch = 1:25)
```

`plot()` имеет несколько режимов отрисовки данных, регулируемых аргументом `type` . Название диаграммы задается аргументом `main` .

Совместно с `plot()` иногда используют функцию `par()` , которая отвечает за обширное количество параметров отображения диаграммы, которые не включены непосредственно в функцию `plot()` . Например, разметку слоя `mfrow` : для возможности отображения нескольких диаграмм одновременно, `mar` - настраивает ширину полей вокруг рисунка.

```{r}
# Зададим разметку слоя 2 на 2 и размер полей 
# задается против часовой стрелки: низ,справа, верх, слева
par(mfrow=c(2,2), mar = c(2,2,2,1))
# Без данных
plot(x = df$X, y = df$Y, col ="blue", type = "n", main = "Пустой")
# Точки
plot(x = df$X, y = df$Y, col ="darkgreen", type = "p", main = "Точки")
# Линия
plot(x = df$X, y = df$Y, col ="red", type = "l", main = "Линии")
# Вертикальные линии
plot(x = df$X, y = df$Y, col ="pink", type = "h", main = "Вертикальные линии")
```

для отображения одновременного несольких типов, например точек и линии, используют **совместно** функцию `plot()` и `points()`, Заголовк можно задать функцией

```{r}
plot(x = df$X, y = df$Y, col ="red", type = "l", main = "Линия, потом точки")
points(x = df$X, y = df$Y, col = "blue", pch = 16) 
```

возможно сделать и наоборот, сначала прорисовать точки, используя `plot()` с параметром `type = "p"`, затем наложить линию через функцию `lines()`.

```{r}
plot(x = df$X, y = df$Y, col ="red", type = "p", pch = 16, main = "Точки, потом Линия")
# Отрисовываем линию поверх диаграммы с точками
lines(x = df$X, y = df$Y, col = "blue")
```

Толщину и тип линии также можно задавать через аргументы `lwd` и `lty` соответсвенно.

```{r}
par(mfrow=c(2,2), mar = c(2,2,2,1))
# Сплошная
plot(x = df$X, y = df$Y, col ="blue", type = "l", lwd = 1, lty = 1, main = "Solid")
# Штрих
plot(x = df$X, y = df$Y, col ="darkgreen", type = "l", lwd = 2, lty = 2, main = "Dashed")
# Точечная
plot(x = df$X, y = df$Y, col ="red", type = "l", lwd = 3, lty = 3,main = "Dotted")
# штрих-пунктирная
plot(x = df$X, y = df$Y, col ="magenta", type = "l", lwd = 3.5, lty = 4,main = "Dash-dot")
```

Названия осей автоматически формируютс из имен фходных данных для соответсвующих осей. Чтобы их изменить используют аргументы `xlab`, `ylab` :

```{r}
plot(x = df$X, y = df$Y, col ="blue", type = "l", xlab = "не Ось Y", ylab = "не Ось X", main = "График с названиями осей )")
```

С помощью параметров `xlim`, `ylim` возможно выполнять масштабирование на область.

```{r}
plot(x = df$X, y = df$Y, type = "l", xlab = "Время, мин", ylab = "Arbitrary units", xlim = c(15,19), ylim = c(80, 100), main = "Увеличинная область")
```

### BARPLOT

\- некоторые аргументы столбчатой диаграммы

`height` - значение высоты столбца;

`names.arg` - подписи столбцов;

`cex.names` - размер метки;

`las = 2` - поворот метки ;

`space` - зазор между столбцами.

```{r}
df <- data.frame(X = 1:25, Y = 5*(1:25)+9, Labs = paste("Gr", df$X, sep = "_"))
# 
barplot(height = df$Y, names.arg = df$Group, las = 2,  cex.names = 0.8, col = "blue")
```

разворот диаграммы:

```{r}
barplot(height = df$Y, names.arg = df$Group, las = 2,  cex.names = 0.8, col = "blue", horiz = TRUE, space = 0)
```

цвет столбцов можно менять, например в зависмости от группы, при этом передаваемое значение цветов необходимо преобразовать в класс `factor`

```{r}
df$Group <- c(rep("A", 6), rep("B", 7), rep("C", 12))
barplot(height = df$Y, names.arg = df$Labs, las = 2,  cex.names = 0.8
        , col = as.factor(df$Group)
        , horiz = FALSE
        , space = 0)
```

### HIST

-применяется для построения частотной гистограммы (не путать с со столбчатой диаграммой):

```{r}
set.seed(42)
norm_dat <- rnorm(500, mean = 0, sd = 2)
# Частотная гистграмма
hist(norm_dat, main = "Normal Distribution", xlab = " ")

# Утановив probability = TRUE , на гистограмме будут отложены вероятности по оси Y 
hist(norm_dat, main = "Normal Distribution", xlab = " ", probability = TRUE)
```

Для отрисовки нескольких гистограмм на одном поле, необходимо объединить функции `plot()` и `hist()` :

```{r}
set.seed(42)
# Вектор случайных значений из гамма распределения
gamma_dat <- rgamma(350, shape = 6)
# Вектор случайных значений из нормального распределения
norm_dat <- rnorm(500, mean = 0, sd = 2)
# Гистограмма выборки из Гамма распределения
hist_gamma <- hist(gamma_dat)
# Гистограмма из выборки  Нормального распределения
hist_norm <- hist(norm_dat)

# Отрисовываем гистограмму нормального распределения через plot() 
plot(hist_norm
     , col = rgb(0, 0, 1, 0.25)
     , xlim = c(-8, 15)
     , main = "Normal & Gamma"
     , xlab ="")

# Добавляем Гамма гистограмму через plot() с аргументом add=TRUE 
plot(hist_gamma, col=rgb(1, 0, 0, 0.25), add=TRUE)

```

В примере выше цвета гистограмм заданы через функцию `rgb()` с каналом полупрозрачности, что делает пересечение диаграмм более наглядным засчет сложения цветов.

### DENSITY PLOT

предназначен для отрисовки плотности распределния вычесленной методом ядерной оценки плотности (*kernel density estimation*).

```{r}
# Среднего арифметиечского для входных данных
mu <- round(mean(norm_dat), digits = 3)
main_title = expression(1/sqrt(2*pi)~e^-(x-mu)^2/sigma^2)
# Создаем крнвеер
norm_dat |>
  density(x= _, bw = 0.5) |>
  plot(, main = main_title, col = "red", xlab="")

# добавим точки данных на оси X в виде рисок синнго цвета с каналом 
# полупрозрачности 0.25
rug(norm_dat, col = rgb(0, 0, 1, 0.25))
# Добавим вертикальные линии в точках 0 и mu 

abline(v = c(0, mu), lty = 2, col = c("blue", "red"))
# Добавим аннотацию в точках 0 и mu 
text(x = mu
     , y = 0.2
     , labels = bquote(bar(x)* "= " * .(mu))
     , pos = 2
     , col = "red"
     , cex = 0.8)
```

`text()` - отрисовывает символьные аннотации, где аргументы `x` и `y` координаты размещения текста, `labels` - собственно текст который нужно добавить к диаграмме, `pos` положение текста относительно точки `x` и `y` (внизу, слева, сверху или справа ); остальные аргументы определяют стиль надписи аналогично ранее рассмотренным функциям. Функция `bquote()` в данном случае используется для отрисовки симола $\bar{x}$ и его значения. Для данной цели также используют функцию `expression()` как пример для формирования заголовка данной диаграммы.

### BOXPLOT

выполняет отрисовку диаграммы *"ящик с усами" .* Удобен для сравнения средних нескольких групп с учетом разброса (и распределения) данных в сравниваемых группах.в данном примере используем встроенный датасет `InsectSprays`

```{r}
head(InsectSprays)
table(InsectSprays$spray)
boxplot(count ~ spray, data = InsectSprays)
```

### 
