---
title: "Lesson_03"
output:
  html_document:
    toc: true
    toc_float: true
---

## ГРАФИКИ И ДИАГРАММЫ

Для построения графиков и диаграмм наиболее часто используют следующие библиотеки

-   `plot {base}` - базовая графика;

-   `ggplot2 {ggplot2 }` - продвинутая графика на основе "грамматических структур";

-   `{lattice}` - Trellis graphics for **R** .

### PLOT

Данные можно строить на рзных типах. Данный пример демонстирует построение простого графика с ипользованием `data.frame` в качестве данных и функцию `plot` .

```{r}
df <- data.frame(X=1:25, Y=5*(1:25)+9)
plot(x = df$X, y = df$Y, col ="red")
```

Предустановлены следующие типы точек (маркеров) :

```{r}
plot(x = df$X, y = df$Y, col ="blue", pch = 1:25)
```

`plot()` имеет несколько режимов отрисовки данных, регулируемых аргументом `type` . Название диаграммы задается аргументом `main` .

Совместно с `plot()` иногда используют функцию `par()` , которая отвечает за обширное количество параметров отображения диаграммы, которые не включены непосредственно в функцию `plot()` . Например, разметку слоя `mfrow` : для возможности отображения нескольких диаграмм одновременно, `mar` - настраивает ширину полей вокруг рисунка.

```{r}
# Зададим разметку слоя 2 на 2 и размер полей 
# задается против часовой стрелки: низ,справа, верх, слева
par(mfrow=c(2,2), mar = c(2,2,2,1))
# Без данных
plot(x = df$X, y = df$Y, col ="blue", type = "n", main = "Пустой")
# Точки
plot(x = df$X, y = df$Y, col ="darkgreen", type = "p", main = "Точки")
# Линия
plot(x = df$X, y = df$Y, col ="red", type = "l", main = "Линии")
# Вертикальные линии
plot(x = df$X, y = df$Y, col ="pink", type = "h", main = "Вертикальные линии")
```

для отображения одновременного несольких типов, например точек и линии, используют **совместно** функцию `plot()` и `points()`, Заголовк можно задать функцией

```{r}
plot(x = df$X, y = df$Y, col ="red", type = "l", main = "Линия, потом точки")
points(x = df$X, y = df$Y, col = "blue", pch = 16) 
```

возможно сделать и наоборот, сначала прорисовать точки, используя `plot()` с параметром `type = "p"`, затем наложить линию через функцию `lines()`.

```{r}
plot(x = df$X, y = df$Y, col ="red", type = "p", pch = 16, main = "Точки, потом Линия")
# Отрисовываем линию поверх диаграммы с точками
lines(x = df$X, y = df$Y, col = "blue")
```

Толщину и тип линии также можно задавать через аргументы `lwd` и `lty` соответсвенно.

```{r}
par(mfrow=c(2,2), mar = c(2,2,2,1))
# Сплошная
plot(x = df$X, y = df$Y, col ="blue", type = "l", lwd = 1, lty = 1, main = "Solid")
# Штрих
plot(x = df$X, y = df$Y, col ="darkgreen", type = "l", lwd = 2, lty = 2, main = "Dashed")
# Точечная
plot(x = df$X, y = df$Y, col ="red", type = "l", lwd = 3, lty = 3,main = "Dotted")
# штрих-пунктирная
plot(x = df$X, y = df$Y, col ="magenta", type = "l", lwd = 3.5, lty = 4,main = "Dash-dot")
```

Названия осей автоматически формируютс из имен фходных данных для соответсвующих осей. Чтобы их изменить используют аргументы `xlab`, `ylab` :

```{r}
plot(x = df$X, y = df$Y, col ="blue", type = "l", xlab = "не Ось Y", ylab = "не Ось X", main = "График с названиями осей )")
```

С помощью параметров `xlim`, `ylim` возможно выполнять масштабирование на область.

```{r}
plot(x = df$X, y = df$Y, type = "l", xlab = "Время, мин", ylab = "Arbitrary units", xlim = c(15,19), ylim = c(80, 100), main = "Увеличинная область")
```

### BARPLOT

\- некоторые аргументы столбчатой диаграммы

`height` - значение высоты столбца;

`names.arg` - подписи столбцов;

`cex.names` - размер метки;

`las = 2` - поворот метки ;

`space` - зазор между столбцами.

```{r}
df <- data.frame(X = 1:25, Y = 5*(1:25)+9, Labs = paste("Gr", df$X, sep = "_"))
# 
barplot(height = df$Y, names.arg = df$Group, las = 2,  cex.names = 0.8, col = "blue")
```

разворот диаграммы:

```{r}
barplot(height = df$Y, names.arg = df$Group, las = 2,  cex.names = 0.8, col = "blue", horiz = TRUE, space = 0)
```

цвет столбцов можно менять, например в зависмости от группы, при этом передаваемое значение цветов необходимо преобразовать в класс `factor`

```{r}
df$Group <- c(rep("A", 6), rep("B", 7), rep("C", 12))
barplot(height = df$Y, names.arg = df$Labs, las = 2,  cex.names = 0.8
        , col = as.factor(df$Group)
        , horiz = FALSE
        , space = 0)
```

### HIST

-применяется для построения частотной гистограммы (не путать с со столбчатой диаграммой):

```{r}
set.seed(42)
norm_dat <- rnorm(500, mean = 0, sd = 2)
# Частотная гистграмма
hist(norm_dat, main = "Normal Distribution", xlab = " ")

# Утановив probability = TRUE , на гистограмме будут отложены вероятности по оси Y 
hist(norm_dat, main = "Normal Distribution", xlab = " ", probability = TRUE)
```

Для отрисовки нескольких гистограмм на одном поле, необходимо объединить функции `plot()` и `hist()` :

```{r}
set.seed(42)
# Вектор случайных значений из гамма распределения
gamma_dat <- rgamma(350, shape = 6)
# Вектор случайных значений из нормального распределения
norm_dat <- rnorm(500, mean = 0, sd = 2)
# Гистограмма выборки из Гамма распределения
hist_gamma <- hist(gamma_dat)
# Гистограмма из выборки  Нормального распределения
hist_norm <- hist(norm_dat)

# Отрисовываем гистограмму нормального распределения через plot() 
plot(hist_norm
     , col = rgb(0, 0, 1, 0.25)
     , xlim = c(-8, 15)
     , main = "Normal & Gamma"
     , xlab ="")

# Добавляем Гамма гистограмму через plot() с аргументом add=TRUE 
plot(hist_gamma, col=rgb(1, 0, 0, 0.25), add=TRUE)

```

В примере выше цвета гистограмм заданы через функцию `rgb()` с каналом полупрозрачности, что делает пересечение диаграмм более наглядным засчет сложения цветов.

### DENSITY PLOT

предназначен для отрисовки плотности распределния вычесленной методом ядерной оценки плотности (*kernel density estimation*).

```{r}
# Среднего арифметиечского для входных данных
mu <- round(mean(norm_dat), digits = 3)
main_title = expression(1/sqrt(2*pi)~e^-(x-mu)^2/sigma^2)
# Создаем крнвеер
norm_dat |>
  density(x= _, bw = 0.5) |>
  plot(, main = main_title, col = "red", xlab="")

# добавим точки данных на оси X в виде рисок синнго цвета с каналом 
# полупрозрачности 0.25
rug(norm_dat, col = rgb(0, 0, 1, 0.25))
# Добавим вертикальные линии в точках 0 и mu 

abline(v = c(0, mu), lty = 2, col = c("blue", "red"))
# Добавим аннотацию в точках 0 и mu 
text(x = mu
     , y = 0.2
     , labels = bquote(bar(x)* "= " * .(mu))
     , pos = 2
     , col = "red"
     , cex = 0.8)
```

`text()` - отрисовывает символьные аннотации, где аргументы `x` и `y` координаты размещения текста, `labels` - собственно текст который нужно добавить к диаграмме, `pos` положение текста относительно точки `x` и `y` (внизу, слева, сверху или справа ); остальные аргументы определяют стиль надписи аналогично ранее рассмотренным функциям. Функция `bquote()` в данном случае используется для отрисовки симола $\bar{x}$ и его значения. Для данной цели также используют функцию `expression()` как пример для формирования заголовка данной диаграммы.

### BOXPLOT

выполняет отрисовку диаграммы *"ящик с усами" .* Удобен для сравнения средних нескольких групп с учетом разброса (и распределения) данных в сравниваемых группах.в данном примере используем встроенный датасет `InsectSprays`

```{r}
head(InsectSprays)
table(InsectSprays$spray)
boxplot(count ~ spray, data = InsectSprays)
```

### ggplot2

[Популярный пакет](https://ggplot2.tidyverse.org/ "ggplot2 website (tidyverse)") для работы с графикой. В синтакасисе использует парадигму послойного построения изображения, т.е. отдельные элементы диаграммы (оси, текст, метки, геометрические фигуры и пр) накладываются слоями, каждый такой слой описывается отдельной командой/строчкой кода. Приступая к работе, следует установить сначала пакет `ggplot2`, используя комманду: `install.packages("ggplot2")` или, если `ggplot2` уже установлен, загрузить пакет, например, `require(ggplot2)`. Работа обычинается с комманды `ggplot2()` в которую в качестве аргументов передают, собственно данные `data` и аргументы базовые эстетические атрибуты, т.е внешний вид диаграммы.

```{r}
# Сгенерируем данные
require(ggplot2)
x <- seq(-10,10, 0.1)
tab <- data.frame(Value = x
                  , Response = exp(-x^2/25))

ggplot(data = tab # передаем данные
       , aes(x = Value, y = Response) # Выбираем столбцы для построение графика
       )
```

как видно `ggplot2()` не создает рисунок, а только генерирует полтно/заготовку для будущего графика, т. е создает первый слой, поверх которого далее будут накладываться элементы графика. Обратите внимание, что границы значений осей выбраны исходя из минимальных и максимальных значений выбранных нами столбцов (`Value` и `Response` ), названия осей также присвоены автоматически на основании заголовков.

Зачастую удобно присвоить резудьтат вызова `ggplot2()` некоторой перемнной и затем использовать ее для для вызова/отображения или для дополнения новыми элементами:

```{r}
# Присвоим результат переменной p
p <- ggplot(data = tab # передаем данные
       , aes(x = Value, y = Response) # Выбираем столбцы для построение графика
       )
p
```

Добавление элементов к графику выполняется путем "присоединения" дополнительного кода к переменной или коду, используя символ "+":

```{r}
# Дополним график элементом из точек
p + geom_point()

# или линией 
p + geom_line()

# или и точками и линиями
p + 
  geom_line() +
  geom_point()
```

Обратите внимание, что само `p` при добавлении элементов не менется. Таким образом, код выше только отображает результат совместного вызова одного, двух и трех элементов соответсвенно. Для обновления `p` необходимо выполнить переприсвоение всего выражени к `->p` . На данном этоапе из соображений наглядности этого сделано не было.

Как и в случае с `plot` форму и размер точек/маркеров и линий возможно менять через аргументы функций, отвечающих за управление элементами графика:

```{r}
p + geom_line(col = "red", linetype = 2)

p + geom_point(col = "blue", shape = 1, size = 1)
```

Добавим и переназначим названия некоторых элеменов графика. Можно определять только необходимое для конкретного случия элементы, в демонстрационных целях использумем все:

```{r}

p <- ggplot(data = tab, aes(x = Value, y = Response)) +
  geom_line(col = "red", linetype = 2) +
  # Блок меток элементов позволяет сразу дать название основным элементам графика
  labs(x = "Значение Х" # Название оси Х
       , y = "ОСЬ Y" # Название оси Y
       , title = "График функции" # Загаловок
       , subtitle = expression("f(x) ="~e^-(x^2/25)) # Подзагаловок
       , caption = format(Sys.time(), "%a %d %b %Y %X") # подпись в нижнем левом углу
       , tag = "(\\_/)\n(='.'=)\n(\")_(\")" # Метка
       )
p
```

В отличие от `plot` в `ggplot2` более удобная настройка осей:

```{r}
 p + scale_x_continuous(limits = c(-8,8) # Установить новые пределы по оси
                     , breaks = seq(-10,10,2) # Шаг шкалы основных линий - 2
                     , expand = expansion(mult = 0, add = 0)# Устраним поля 
                     # (padding) по краям графика
                     , minor_breaks = seq(-10,10,1) # промежуточные линии сетки - 1
                     ) +
   # Жобавим промежуточные риски шаг соответствует minor_breaks
   guides(x = guide_axis(minor.ticks = TRUE)) + 
   # Отобразим значений оси Y в %
   scale_y_continuous(labels = scales::label_percent()) 
  
```

`scale_x_continuous` и `scale_y_continuous` - предлагают гибкую настройку осей запись `scales::label_percent()`- означает вызов фугкции `label_percent()` прямо из пакета `scales` без его полной загрузки, если пакет `scales` не установлен - функция не отработает.

Ещё больше настроек элементов внешнего вида скрыто в настройках тем `?theme`, `ggtheme`

```{r}
p + theme(legend.position = "none"
    , panel.grid = element_blank()
    , axis.text.y = element_blank()
    , axis.title.y = element_blank()
    , axis.ticks.y = element_blank()
    , axis.text.x = element_text(size = 12)
    , axis.title.x = element_text(size = 12)
    , panel.background = element_rect(fill = "pink")
    , plot.background = element_rect(fill = "lightblue")
    )
```

```{r}
p + theme_bw()
p + theme_dark()
p + theme_minimal()
```

## РАСПОЛОЖЕНИЕ НЕСКОЛЬКИХ ГРАФИКОВ НА ОДНОМ РИСУНКЕ

Для размещения однотипных диаграмм удобно использовать `facet_grid()` или `facet_wrap()` . В таком случае входные данные должны как минимум отвечать следующей структуре `data.frame()`:

|  X  |  Y  | Label |
|:---:|:---:|:-----:|
|  1  |  4  |   A   |
|  3  |  5  |   A   |
|  9  | 10  |   B   |

Здесь колонка `Label` используется для установки меток, по которым `ggplot` определяет какие именно строки к какому графику относятся. Метками могут быть, впинципе, любые данные, но чтобы они воспринимались `ggplot` корректно их нужно конвертировать в `factor`. Факторы это структурный тип данных `R` на подобии вектора, однако у некго есть уровни, а также определенные ограничения на содержание элементов.

[![Attributes of Factors in R Language](https://media.geeksforgeeks.org/wp-content/uploads/20200402234648/attributes.jpg)](https://www.geeksforgeeks.org/r-factors/)

создание фактора:

```{r}
vec <- c("A", "B", "B", "B", "C")
a <- factor(vec)
a

as.factor(vec)
```

ещё один способ:

```{r}
z<-gl(n = 2, k = 8, labels = c("Control", "Treat"))
class(z)

z
```

Теперь создадим данные для построения композитного рисунка из нескольких диаграмм для этого создадим таблицу с помощью конструктора `data.frame` и затем трансформируем данную таблицу в длинный `long` формат.

```{r}
x <- seq(-10,10, length.out=50)
df <- data.frame(X=x
                 , A= -5*x+9
                 , B= -0.5*x**2 - 13*x +23
                 , C= -0.7*x**3 - 3*x**2 +7
                 , D= (x**2-x**4))
head(df)

df_re <- reshape(data = df
                 , direction = "long" # Определяет в какую форму трансформировать
                 , varying = list(2:5) # Какие столбцы следует объеденить
                 , times = names(df)[-1] # Задает метки для будущего фактора
                 , timevar = "Class" # Название столбца с метками
                 , v.names = "Value") # название столбца с объединенными значениями
head(df_re, n = 15)

sapply(df_re, class)
                 
```

Далее выполняем отрисовку графиков:

```{r}
p <- ggplot(data = df_re, aes(x=X, y=Value, col=Class)) +
  geom_point() +
  theme_bw()
p
```

Для того чтобы разделить данные воспользуемся функциями `facet_grid()` или `facet_wrap()`

```{r}
p + facet_grid(cols = vars(Class))

p + facet_grid(rows = vars(Class))

p + facet_wrap(facets = vars(Class), scales = "free", nrow = 2)
```

Для создания более сложных композиций см [статью](https://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/81-ggplot2-easy-way-to-mix-multiple-graphs-on-the-same-page/ "Пакеты для создания композиций из диаграмм")
